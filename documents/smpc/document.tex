\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\geometry{margin=1in}

% Code listing configuration - Rust-like syntax highlighting
\definecolor{rustblue}{RGB}{26,94,180}
\definecolor{rustgreen}{RGB}{23,155,79}
\definecolor{rustorange}{RGB}{251,146,60}
\definecolor{rustpurple}{RGB}{139,92,246}
\definecolor{rustgray}{RGB}{108,117,125}
\definecolor{rustbg}{RGB}{248,249,250}

\lstdefinestyle{ruststyle}{
    language=C++,  % Base language
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{rustblue}\bfseries,
    commentstyle=\color{rustgreen}\itshape,
    stringstyle=\color{rustorange},
    numberstyle=\tiny\color{rustgray},
    backgroundcolor=\color{rustbg},
    frame=single,
    frameround=tttt,
    rulecolor=\color{gray!30},
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=2,
    numbers=left,
    stepnumber=1,
    numbersep=8pt,
    xleftmargin=15pt,
    xrightmargin=5pt,
    % Rust-specific keywords
    morekeywords={pub, fn, impl, struct, enum, trait, Self, Option, Vec, usize, u8, u16, u32, u64, i8, i16, i32, i64, bool, str, String, mut, let, const, static, ref, move, async, await, match, if, else, for, while, loop, break, continue, return, match, Some, None, Ok, Err, Result, Box, Arc, Rc, RefCell, Cell, Mutex, RwLock},
    keywordstyle=[2]\color{rustpurple}\bfseries,
    morekeywords=[2]{derive, Clone, Debug, PartialEq, Eq, Copy, Send, Sync},
    keywordstyle=[3]\color{rustorange},
    morekeywords=[3]{true, false},
    keywordstyle=[4]\color{rustblue},
    morekeywords=[4]{self, super, crate},
    escapeinside={(*@}{@*)},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
}

\lstset{style=ruststyle}

\title{SMC Assignments -- Garbled Circuits}
\author{Lorenzo Deflorian}
\date{\today}

\begin{document}

\maketitle

\section{Assignment 1: Mini Garbled Circuit}

This assignment builds a tiny garbled circuit for a single NAND gate using Yao's construction. The code creates random wire labels, garbles the gate into a small garbled table, and then evaluates the table to compute NAND without exposing the underlying bits.

\subsection{Implementation Overview}

There are three moving pieces:

\begin{enumerate}
    \item \textbf{Wire Labels:} Each wire $w \in \{x, y, z\}$ gets two fresh 128-bit labels, one for 0 and one for 1:
\begin{lstlisting}
pub struct WireLabels {
    pub zero: WireLabel,  // L_w^0
    pub one: WireLabel,   // L_w^1
}

impl WireLabels {
    pub fn random<R: RngCore + ?Sized>(rng: &mut R) -> Self {
        Self {
            zero: WireLabel::random(rng),
            one: WireLabel::random(rng),
        }
    }
}
\end{lstlisting}

    \item \textbf{Garbling:} The garbler encrypts the correct output label for every input pair:
\begin{lstlisting}
// Build the 4 ciphertexts C[a,b] = Enc(K[a,b], L^{a NAND b}_z)
for (a, b) in &[(0u8, 0u8), (0, 1), (1, 0), (1, 1)] {
    let in_x = if *a == 0 { &x_labels.zero } else { &x_labels.one };
    let in_y = if *b == 0 { &y_labels.zero } else { &y_labels.one };
    
    let nand_result = if *a == 1 && *b == 1 { 0 } else { 1 };
    let out_z = if nand_result == 0 { &z_labels.zero } else { &z_labels.one };
    
    let k = derive_key(in_x, in_y);  // K[a,b] = KDF(L_x^a || L_y^b)
    let c = encrypt_label(&k, out_z); // C[a,b] = Enc(K[a,b], L_z^{NAND(a,b)})
    table.push(c);
}
fastrand::shuffle(&mut table);  // Randomize order
\end{lstlisting}

    \item \textbf{Evaluation:} The evaluator tries to decrypt each entry until one yields a valid output label:
\begin{lstlisting}
pub fn evaluate(&self, inputs: GarbledNandInputs) -> GarbledNandOutput {
    for c in &self.table {  // Try all 4 ciphertexts
        let k = derive_key(&inputs.x, &inputs.y);
        let decoded = decrypt_label(&k, c);
        
        if decoded == self.z_labels.zero || decoded == self.z_labels.one {
            return GarbledNandOutput { z: decoded };
        }
    }
    // Exactly one decryption succeeds
}
\end{lstlisting}
\end{enumerate}

\subsection{(a) Correctness: Why Exactly One Ciphertext Decrypts Correctly}

At evaluation time, the evaluator holds one label for $x$ ($L_x^a$) and one for $y$ ($L_y^b$), with $a,b \in \{0,1\}$. From those two labels the evaluator derives a single key $K = \text{KDF}(L_x^a || L_y^b)$ and tries it against the four ciphertexts in the table.

Only one entry opens successfully, for these reasons:

\begin{enumerate}
    \item \textbf{Deterministic key derivation:} The same pair of input labels always maps to the same key $K[a,b]$. In the code this is:
\begin{lstlisting}
fn derive_key(x: &WireLabel, y: &WireLabel) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(&x.0);  // L_x^a
    hasher.update(&y.0);  // L_y^b
    let result = hasher.finalize();
    // Returns K = SHA256(L_x^a || L_y^b)
}
\end{lstlisting}
    
    \item \textbf{Each table entry uses its own key:} During garbling we derive four keys, one per input pair, and encrypt the matching output label $L_z^{\text{NAND}(a,b)}$ under each key to form $C[a,b]$.
    
    \item \textbf{Only the matching key works:} The derived key matches exactly one of the four garbling keys. Decrypting the other three entries with the wrong key produces garbage that will not equal any valid output label.
    
    \item \textbf{Valid labels are recognizable:} The evaluator knows both possible output labels $L_z^0$ and $L_z^1$, so they can spot the one correct decryption.
\end{enumerate}

So the cryptographic setup guarantees that exactly the ciphertext corresponding to the true inputs $(a,b)$ yields a valid output label; all other attempts fail.

\subsection{(b) Inefficiency: Why Four Decryptions Are Required}

The evaluator has to try all four ciphertexts because:

\begin{enumerate}
    \item \textbf{The table is shuffled:} The four ciphertexts are stored in random order to hide which entry matches which input pair.
    
    \item \textbf{The evaluator cannot pick the right entry upfront:} The labels do not reveal the underlying bits, so there is no way to select the correct ciphertext without trying it.
    
    \item \textbf{Success is only visible after decryption:} The evaluator only discovers the valid label after decrypting, so all entries must be checked. The loop in the code makes this explicit:
\begin{lstlisting}
for c in &self.table {  // Must iterate through all 4 entries
    let k = derive_key(&inputs.x, &inputs.y);
    let decoded = decrypt_label(&k, c);
    
    if decoded == self.z_labels.zero || decoded == self.z_labels.one {
        // Found valid output, but had to try all entries
        return GarbledNandOutput { z: decoded };
    }
}
\end{lstlisting}
\end{enumerate}

This is a known limitation of the bare-bones construction. Optimizations such as point-and-permute or free-XOR can cut down the number of decryptions.

\section{Assignment 2: Garbled Circuits in Practice}

Here the goal is privacy-preserving array equality. Alice and Bob each have a private boolean array of length $n$ and want to learn only whether all positions match: $\bigwedge_i (a_i = b_i)$. The implementation provides two versions: a fully oblivious one and a faster early-exit (leaky) version that leaks limited information.

\subsection{Implementation Overview}

Both versions implement the same circuit. For each index $i$, equality $a_i = b_i$ is built as $(a_i \land b_i) \lor (\lnot a_i \land \lnot b_i)$ using NAND gates, and then all equalities are combined with an AND chain. The difference is in control flow: the oblivious version always runs through all $n$ indices, while the early-exit version stops at the first mismatch.

\subsection{Threat Model}

We assume semi-honest (honest-but-curious) adversaries. The protocol \textbf{protects}:
\begin{itemize}
    \item \textbf{Individual inputs:} Alice's array $A = (a_0, \ldots, a_{n-1})$ and Bob's array $B = (b_0, \ldots, b_{n-1})$ stay secret; only the final match/no-match bit is revealed.
    \item \textbf{Intermediate values:} In the oblivious version, per-index equality results are never decoded, only the final AND output.
\end{itemize}

The protocol does \textit{not} protect against malicious parties who deviate from the protocol, nor does it address side channels (timing, power) beyond what is discussed below.

\subsection{Leakage Analysis}

\textbf{Oblivious version:} The oblivious implementation always processes all $n$ indices. Control flow is data-independent, so runtime is (to first order) independent of the input values. The only thing revealed is the final boolean output.

\textbf{Early-exit (leaky) version:} The early-exit implementation stops as soon as it finds a mismatch. This creates \textbf{timing leakage}: anyone who can measure runtime can infer the \textit{index of the first mismatch}. Formally, the leakage function is:
\[
\mathcal{L}(A, B) = \min\{i : a_i \neq b_i\}
\]
with the convention that if $A = B$, the leakage is $n$. From the runtime, an adversary learns how many indices were checked before the mismatch.

\subsection{Trade-off Discussion}

The early-exit (leaky) version intentionally reveals the index of the first mismatch in exchange for performance. The oblivious version must always build and evaluate the full AND chain over all $n$ equality results; the early-exit version skips that work by decoding each equality as it goes and returning as soon as one fails. This makes runtime depend on how far the arrays match before they diverge, which is exactly the timing leakage described above. The trade-off is explicit: sacrifice index privacy for faster execution when mismatches occur early, which can matter in settings where arrays often differ near the start (for example, version hashes, checksums, or incremental comparisons).

\textbf{When the additional leakage may be acceptable:}
\begin{itemize}
    \item \textbf{Non-adversarial settings:} Both parties are trusted and efficiency matters (for example, internal checks or debugging).
    \item \textbf{Index is non-sensitive:} The location of the mismatch is not confidential (for example, version comparisons where the value matters more than the position).
    \item \textbf{Controlled environments:} Timing channels are mitigated with constant-time code or padded delays.
\end{itemize}

\textbf{When the leakage is unacceptable:}
\begin{itemize}
    \item \textbf{Privacy-critical applications:} The index itself is sensitive (for example, which digit differs in a password, or the position of a matching record in a database).
    \item \textbf{Adversarial settings:} One party may be compromised and timing measurements are feasible.
    \item \textbf{Regulatory compliance:} Strict privacy guarantees are required (no auxiliary leakage).
\end{itemize}

\subsection{Performance Evaluation}

Both versions were benchmarked for $n \in \{4, 8, 16\}$ with all elements equal (worst case for the early-exit version, since it has to check everything). Results are from a single run in debug mode:

\begin{center}
\begin{tabular}{lrr}
\hline
$n$ & Oblivious (s) & Leaky (s) \\
\hline
4  & 0.0017 & 0.0014 \\
8  & 0.0032 & 0.0027 \\
16 & 0.0065 & 0.0064 \\
\hline
\end{tabular}
\end{center}

The oblivious version is slower because it builds and evaluates the full AND chain over all equalities. The early-exit version avoids that chain by decoding each equality and returning early. For arrays with an early mismatch, the speedup would be larger (for example, a mismatch at index 0 means minimal work). Both versions scale roughly linearly with $n$, as expected from the circuit size.

\vspace{1em}
\noindent\textit{Note:} The \texttt{README.md} in the \texttt{smpc} directory contains instructions to build and run the code.

\end{document}
